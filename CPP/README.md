## CPP

#### 1. Eigen 库使用

* 内存对齐

`EIGEN_MAKE_ALIGNED_OPERATOR_NEW` 是 Eigen 库提供的一个宏，用于确保包含特定类型的类在动态分配内存时进行正确的内存对齐。特别是在类中包含固定大小的 Eigen 类型（例如 Eigen::Vector3d、Eigen::Matrix3d 等）时，为了在某些架构上获得最佳性能，就需要进行特殊的内存对齐。

**EIGEN_MAKE_ALIGNED_OPERATOR_NEW 的作用**:它会为类重载 new 和 delete 操作符，以确保内存对齐适合 Eigen 类型。它避免了由于对齐问题导致的崩溃或性能问题。


#### 2.

* size_t

size_t 是 C 和 C++ 中一种用于表示内存大小的无符号整数类型。它通常用于数组、容器或任何其他需要表示大小或索引的场景。

**size_t大小**:在 32 位系统中，size_t 通常是一个 4 字节（32 位）的无符号整数。在 64 位系统中，size_t 通常是一个 8 字节（64 位）的无符号整数。

**size_t 主要用于表示**：
    数组或容器的大小：例如，std::vector 的大小通常是 size_t 类型。
    内存分配：比如，malloc() 或 new 操作符返回的内存大小是 size_t 类型。
    循环和索引：因为 size_t 是无符号的，所以它通常用于表示容器的索引或循环的范围，避免负值的错误。

**为什么使用 size_t**:使用 size_t 的一个重要原因是它能最大限度地适应不同平台的大小需求。特别是在处理数组或动态内存时，size_t 能提供足够大的范围来表示内存大小或容器的大小。它的无符号特性确保了不会出现负值，这对许多情况下的边界检查非常重要。

* inline 

inline 关键字用于建议编译器在调用函数时将函数代码直接嵌入到调用位置，而不是通过正常的函数调用机制跳转。

**优势**：减少函数调用开销、增加代码的执行效率和编译器优化的建议。

**使用限制**:递归函数不适合内联，较大函数不适合内联。

* operator

运算重载

可重载运算符/不可重载运算符

下面是可重载的运算符列表：
- 双目算术运算符 	+ (加)，-(减)，*(乘)，/(除)，% (取模)
- 关系运算符 	==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于)
- 逻辑运算符 	||(逻辑或)，&&(逻辑与)，!(逻辑非)
- 单目运算符 	+ (正)，-(负)，*(指针)，&(取地址)
- 自增自减运算符 	++(自增)，--(自减)
- 位运算符 	| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移)
- 赋值运算符 	=, +=, -=, *=, /= , % = , &=, |=, ^=, <<=, >>=
- 空间申请与释放 	new, delete, new[ ] , delete[]
- 其他运算符 	()(函数调用)，->(成员访问)，,(逗号)，[](下标)

下面是不可重载的运算符列表：

- .：成员访问运算符
- .*, ->*：成员指针访问运算符
- ::：域运算符
- sizeof：长度运算符
- ?:：条件运算符
- #： 预处理符号
